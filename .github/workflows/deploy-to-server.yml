# This workflow deploys to production server when Server directory changes are pushed to main or when workflow file is updated.
name: Deploy to Production Server

on:
  push:
    branches: [ "main" ]
    paths:
      - 'Server/**'  # Only trigger when files in Server directory change
      - '.github/workflows/deploy-to-server.yml'  # Also trigger if this workflow file changes

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    # Use environment secrets for production deployment
    environment:
      name: production
      url: https://mqtt-dhbw-hdh-ai2024.duckdns.org/
    
    steps:
    - name: Deploy to server via SSH
      uses: appleboy/ssh-action@v1
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        script: |
          echo "🚀 Starting deployment..."
          
          # Navigate to project directory first
          cd /root/second-semester-project

          # Configure git to use SSH
          git remote set-url origin git@github.com:xMaxximum/second-semester-project.git
          
          # Set up the deploy key properly
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configure git to use the deploy key and handle divergent branches
          git config core.sshCommand "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
          git config pull.rebase false
          
          # Pull latest changes from main branch (force overwrite local changes)
          echo "📥 Pulling latest changes..."
          git fetch origin main
          git reset --hard origin/main
          
          # Clean up the deploy key
          rm -f ~/.ssh/deploy_key
          
          # Navigate to Server directory
          cd Server
          
          # Ensure data directories exist on HOST with proper permissions
          echo "📁 Creating host data directories..."
          mkdir -p ./Server/Data/DataProtection-Keys
          
          # Set proper ownership and permissions
          # Make sure the directory is writable by the Docker container user
          sudo chown -R $USER:$USER ./Server/Data
          chmod -R 777 ./Server/Data  # More permissive for Docker debugging
          
          # Stop existing containers
          echo "🛑 Stopping existing containers..."
          docker compose down
          
          # Comprehensive Docker cleanup to prevent disk space issues
          echo "🧹 Performing comprehensive Docker cleanup..."
          
          # Show current disk usage
          echo "📊 Current Docker disk usage:"
          docker system df
          

          echo "🗑️  Removing stopped containers..."
          docker container prune -f
          
          # Remove any dangling images that might still exist
          echo "🏷️  Removing dangling images..."
          docker image prune -f
          
          # Remove unused build cache (keeps recent cache layers)
          echo "💾 Cleaning build cache..."
          docker builder prune -f --keep-storage 2GB
          
          # Show disk usage after cleanup
          echo "📊 Docker disk usage after cleanup:"
          docker system df

          export COMPOSE_BAKE=true
          
          # Build containers with cache optimization
          echo "🔨 Building containers..."
          docker compose build
          
          # Start containers
          echo "🚀 Starting containers..."
          docker compose up -d
          
          # Wait for containers to start and SSL to initialize
          echo "⏳ Waiting for containers to start"
          sleep 10
          
          # Check if containers are running
          echo "✅ Checking container status..."
          docker compose ps
          
          # Verify all containers are running (not exited)
          echo "🔍 Verifying container health..."
          FAILED_CONTAINERS=$(docker compose ps --format "table {{.Name}}\t{{.Status}}" | grep -E "(Exit|Restarting|Dead)" || true)
          
          if [ ! -z "$FAILED_CONTAINERS" ]; then
            echo "❌ Failed containers detected:"
            echo "$FAILED_CONTAINERS"
            echo "📋 Container logs for debugging:"
            docker compose logs --tail=50
            echo "💥 Deployment failed due to container failures!"
            exit 1
          fi
          
          # Check for critical errors in server container logs
          echo "🔍 Checking for server errors..."
          SERVER_ERRORS=$(docker compose logs server --tail=20 | grep -i -E "(error|exception|fail|fatal)" || true)
          
          if [ ! -z "$SERVER_ERRORS" ]; then
            echo "❌ Critical errors found in server container:"
            echo "$SERVER_ERRORS"
            echo "📋 Full server logs:"
            docker compose logs server --tail=50
            echo "💥 Deployment failed due to server errors!"
            exit 1
          fi
          
          # Final container status check
          echo "✅ Final container status check..."
          docker compose ps
          
          # Show recent logs one more time for confirmation
          echo "📋 Recent container logs:"
          docker compose logs --tail=20
          
          echo "🎉 Deployment completed!"
