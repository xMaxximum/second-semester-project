# This workflow deploys to production server when Server directory changes are pushed to main or when workflow file is updated.
name: Deploy to Production Server

on:
  push:
    branches: [ "main" ]
    paths:
      - 'Server/**'  # Only trigger when files in Server directory change
      - '.github/workflows/deploy-to-server.yml'  # Also trigger if this workflow file changes

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    # Use environment secrets for production deployment
    environment:
      name: production
      url: https://mqtt-dhbw-hdh-ai2024.duckdns.org/
    
    steps:
    - name: Deploy to server via SSH
      uses: appleboy/ssh-action@v1
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.PORT || 22 }}
        script: |
          echo "ğŸš€ Starting deployment..."
          
          # Navigate to project directory first
          cd /root/second-semester-project

          # Configure git to use SSH
          git remote set-url origin git@github.com:xMaxximum/second-semester-project.git
          
          # Set up the deploy key properly
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Configure git to use the deploy key and handle divergent branches
          git config core.sshCommand "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"
          git config pull.rebase false
          
          # Pull latest changes from main branch (force overwrite local changes)
          echo "ğŸ“¥ Pulling latest changes..."
          git fetch origin main
          git reset --hard origin/main
          
          # Clean up the deploy key
          rm -f ~/.ssh/deploy_key
          
          # Navigate to Server directory
          cd Server
          
          # Ensure data directories exist on HOST with proper permissions
          echo "ğŸ“ Creating host data directories..."
          mkdir -p ./Server/Data/DataProtection-Keys
          
          # Set proper ownership and permissions
          # Make sure the directory is writable by the Docker container user
          sudo chown -R $USER:$USER ./Server/Data
          chmod -R 777 ./Server/Data  # More permissive for Docker debugging
          
          # Stop existing containers
          echo "ğŸ›‘ Stopping existing containers..."
          docker compose down
          
          # Comprehensive Docker cleanup to prevent disk space issues
          echo "ğŸ§¹ Performing comprehensive Docker cleanup..."
          
          # Show current disk usage
          echo "ğŸ“Š Current Docker disk usage:"
          docker system df
          

          echo "ğŸ—‘ï¸  Removing stopped containers..."
          docker container prune -f
          
          # Remove any dangling images that might still exist
          echo "ğŸ·ï¸  Removing dangling images..."
          docker image prune -f
          
          # Remove unused build cache (keeps recent cache layers)
          echo "ğŸ’¾ Cleaning build cache..."
          docker builder prune -f --keep-storage 2GB
          
          # Show disk usage after cleanup
          echo "ğŸ“Š Docker disk usage after cleanup:"
          docker system df

          export COMPOSE_BAKE=true
          
          # Build containers with cache optimization
          echo "ğŸ”¨ Building containers..."
          docker compose build
          
          # Start containers
          echo "ğŸš€ Starting containers..."
          docker compose up -d
          
          # Wait for containers to start and SSL to initialize
          echo "â³ Waiting for containers to start"
          sleep 10
          
          # Check if containers are running
          echo "âœ… Checking container status..."
          docker compose ps
          
          # Verify all containers are running (not exited)
          echo "ğŸ” Verifying container health..."
          FAILED_CONTAINERS=$(docker compose ps --format "table {{.Name}}\t{{.Status}}" | grep -E "(Exit|Restarting|Dead)" || true)
          
          if [ ! -z "$FAILED_CONTAINERS" ]; then
            echo "âŒ Failed containers detected:"
            echo "$FAILED_CONTAINERS"
            echo "ğŸ“‹ Container logs for debugging:"
            docker compose logs --tail=50
            echo "ğŸ’¥ Deployment failed due to container failures!"
            exit 1
          fi
          
          # Check for critical errors in server container logs
          echo "ğŸ” Checking for server errors..."
          SERVER_ERRORS=$(docker compose logs server --tail=20 | grep -i -E "(error|exception|fail|fatal)" || true)
          
          if [ ! -z "$SERVER_ERRORS" ]; then
            echo "âŒ Critical errors found in server container:"
            echo "$SERVER_ERRORS"
            echo "ğŸ“‹ Full server logs:"
            docker compose logs server --tail=50
            echo "ğŸ’¥ Deployment failed due to server errors!"
            exit 1
          fi
          
          # Final container status check
          echo "âœ… Final container status check..."
          docker compose ps
          
          # Show recent logs one more time for confirmation
          echo "ğŸ“‹ Recent container logs:"
          docker compose logs --tail=20
          
          echo "ğŸ‰ Deployment completed!"
